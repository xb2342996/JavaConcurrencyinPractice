# 组合对象
## 设计线程安全的类 design thread-safe class
设计线程安全的类应该包括下面3个基本要素：
+ 确定对象状态是由那些变量构成；
+ 确定限制状态变量的不变约束；
+ 制定一个管理并发访问对象状态的策略。

同步策略定义了对象如何协调对其状态的访问，并且不会违反他的不变约束或后验条件。

### 收集同步需求
维护类的线程安全性意味着要确保在并发访问的情况下，保护她的不变约束；需要对类的状态进行判断。
<br>对象与变量拥有一个状态空间（status space）：即他们可能处于的状态。状态空间越小，越容易判断。
<br>尽量使用final类型的域来简化我们对对象的可能状态进行分析。
<br>很多类通过不可变约束来判定一种状态是合法的还是非法的。
<br>操作的后验条件会指出某种状态转换是非法的。
<br>不变约束与后验条件施加在状态及状态转换上的约束，引入了额外的同步与封装。如果某些状态是非法的，则必须封装该状态下的状态变量。
<br>如果一个操作的过程可能出现非法状态转换，则这个操作必须是原子的。

### 状态依赖操作
类的不变约束与方法后验条件约束了对象的合法状态和合法状态转换。某些对象的方法也有基于状态的先验条件。

### 状态所有权
很多情况下，所有权与封装权总是同时出现：对象封装他拥有的状态，且拥有他封装的状态。拥有给定状态的所有者决定了锁协议，该协议用于维护变量状态的完整性。所有权意味着控制权，一旦你将引用发布到一个可变对象上，你不再拥有独占的控制权，充其量只有共享控制权。类通常不会拥有构造函数或方法传递进来的对象，除非该方法是被明确设计用来转换对象的所有权。

## 实例限制 Instance Confinement
即使一个对象不是线程安全的，仍然有许多技术可以让他用于线程安全的程序。
<br>通过使用实例限制，封装简化了类的线程安全化工作，这通常被称为限制（confinement）。当一个对象被另一个对象封装时，所有访问被访问的对象的代码路径是已知的，更容易对代码的路径进行分析。
<br>将数据封装在对象内部，把对数据的访问限制在对象的方法上，更容易确保线程在访问数据的过程中总能获得正确的锁。
<br>被限制的对象一定不能逃逸到它的可用范围之外。
<br>实例限制是构建线程安全类的最简单的方法之一。它还使得对象锁策略的选择更富有灵活性。实例限制还允许不同的锁保护不同的状态变量。

### Java监视器模式
使用私有锁对象，而不是对象的内部锁（或任何其他可公共访问的锁），有很多好处。私有的锁对象可以封装锁，这样外部代码无法得到他。

## 委托线程安全 Delegating Thread Safety
一些情况下，由线程安全的组件组合而成的组件是线程安全的。

### 非状态依赖变量
也可以将线程安全委托到多个隐含的状态变量上，只要这些变量彼此独立的，那么组合对象并未增加任何涉及多个状态变量的不变约束。

### 当委托失效时
如果类还存在复核操作，单独委托仍然不是线程安全的正确方法，在这种情况下，类必须提供它自有的锁以保证复核操作的原子性，除非整个复核操作委托给一个状态变量。
<br>如果一个类有多个彼此独立的线程安全的状态组成，并且类的操作不包含任何无效状态转换时，可以将线程安全委托给这些状态

### 发布底层的状态变量
如果一个状态变量是线程安全的，没有任何不变约束限制他的值，并且没有任何状态转换限制他的操作，那么他可以被安全发布。