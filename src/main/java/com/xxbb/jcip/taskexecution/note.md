# 任务执行 Task Execution
大多数并发应用程序是围绕任务进行管理的。所谓任务就是抽象、离散的工作单元。

## 在线程中执行任务 Executing tasks in thread
围绕执行任务来管理应用程序时，第一步要指明清晰的任务边界。理想状态下，任务是独立的活动，他的工作并不依赖于其他任务的状态、结果或者边界效应。

在正常的负载下，服务器应用程序应具备良好的吞吐量和快速的响应速度。进一步讲，应用程序应该在过载时平缓的劣化，而不是负载一高就简单的以失败告终。为了达到这个目的，你要选择一个清晰的任务边界，并配合一个明确的任务执行策略。

### 顺序执行任务
应用程序内部的任务调度，存在多种可能的调度策略，这些策略可以在不同程度上发挥潜在的并发性。其中最简单的策略是在单一的线程中顺序的执行任务。

对于一个单线程化的服务器，阻塞不仅仅延长了当前请求的完成，而且还阻止了需要被处理的等待请求。如果请求阻塞的时间过长，用户将看不到响应，可能认为服务器已经不可用。同时，单线程在等待他的I/O操作时，CPU会处于闲置状态，导致资源利用率过低。

### 显示的为任务创建线程
为了更好的响应性，可以为每个服务请求创建一个新的线程。

主循环为每个链接创建一个新的线程，而不在主循环内部处理，有3个特点：
1. 执行任务已经脱离主线程，使得主线程可以更快的响应下一个链接。这使得程序可以在前面的请求完成前接收新的请求，从而提高响应性。
2. 并行处理任务，使得多个请求可以同时服务，如果有多个处理器，或者I/O未完成、锁请求以及资源可用性等因素需要阻塞任务时，吞吐量会得到提高。
3. 任务处理代码必须是线程安全的，因为会有多个任务并发的调用。

只要请求的到达速度尚未超出服务器的请求处理能力，那么这种方法可以同时带来更快的响应性和更大的吞吐量。

### 无限创建的缺点
1. 线程生命周期的开销。线程的创建与关闭不是"免费"的。创建线程需要时间，带来请求延迟。如果请求频繁且轻量，就像大多数程序服务器一样，那么每个请求创建一个新的线程的做法会消耗大量的计算资源。
2. 资源消耗量。活动线程会消耗系统资源，尤其是内存。如果可以运行的线程多于可用的处理器数，线程将会限制。大量空闲线程会占用更多内存，给垃圾回收带来压力，大量的线程竞争CPU资源，还会产生其他性能开销。
3. 稳定性。应限制可创建线程的数目。限制的大小视不同平台而定，同时也受到JVM的启动参数，Thread的构造函数中请求的栈的大小等因素，以及底层操作系统的限制。打破这些限制的后果可能会有OOM的错误。

## Executor
任务是逻辑上的工作单元，线程是使任务异步的机制。线程池为管理线程提供了防止程序过载而耗尽内存。

### 执行策略
一个执行策略明确指明了任务执行的"what, where, when, how"，包括：
- 任务在什么线程中执行；
- 任务以什么顺序执行；
- 可以多少个任务并发执行；
- 可以多少个任务进入等待执行队列；
- 如果系统过载，需要放弃一个任务，应该挑选哪个任务？并通知程序知道这一切；
- 任务执行结束前后应该如何处理。

执行策略是资源管理工具。最佳策略资源取决于可用计算资源和对服务质量的需求。通过限制并发数量，确保程序不会由于资源耗尽而失败，大量的任务也不会在争夺稀缺资源时出现性能问题。

### 线程池
在线程池中执行任务线程，比单线程单任务有无可比拟的优势。重用线程资源，而不是创建线程，可以抵消处理请求时线程的创建与消亡产生的开销。另一个好处是，当请求到达时，工作线程通常已经存在，用于创建线程的等待时间并不会延迟任务的执行，提高了响应性。通过调整线程池的参数，动态保持线程池处于忙碌状态，同时防止过多的线程竞争资源，导致内存耗尽。

### Executor声明周期
ExecutorService的生命周期暗含了3种状态：运行（running）、关闭（shutting down）和终止（terminated）。
- ExecutorService被初始化后的处于运行状态。
- shutdown方法会启动一个**平缓的关闭**过程：**停止接收新的任务，并等待已提交的任务完成，包括尚未开始执行的任务。**
- shutdownNow方法会启动一个**强制关闭**的过程：**尝试取消所有运行中的任务和排队中尚未开始的任务。**

一旦所有任务全部完成后，ExecutorService会转入终止状态。可以调用awaitTermination等待ExecutorService到达终止状态，也可以通过isTerminated检查ExecutorService是否终止。

### 延迟且周期性的任务
如果你需要构建自己的调度服务，仍然可以使用了类库提供的DelayQueue，为ScheduledThreadPoolExecutor提供了调度功能。

## 寻找可拓展的并发
顺序执行的方法可能没有充分的利用cpu，并且用户如果想看到完整的文档必须，等待更长的时间。通过将问题分散到独立的可并发的执行任务中，会获得更好的CPU利用率和响应性。

### 可携带结果的任务：Future和Callable
Executor使用Runnable做为任务的基本表达形式，Runnable只是一个非常有限的抽象，run方法不能返回一个值或者抛出一个异常。

很多任务都会引起严重的计算延迟，对于这些任务Callable是一个更好的抽象。

Runnable和Callable描述的是抽象的计算型任务。他们有一个明确的开始点，并且最终都会结束。一个Executor执行任务的生命周期有四个阶段：创建，提交，开始和完成。

Future描述了任务的声明周期，提供了相关的方法来获取任务的结果、取消任务以及校验任务是否完成还是被取消。

任务的状态决定了get()的行为。如果任务已完成，get会立即返回一个结果或异常，如果没有完成get会阻塞直到他完成。如果任务抛出一个异常，get会将这个异常封装在ExecutorException中，然后重新抛出。如果任务被取消，get会抛出一个CancellationException。

状态依赖性是get的内在特性，他意味着调用者不需要知道任务的状态。任务的提交与获取的结果的安全发布特性，确保了这个方法是线程安全的。

### 并行运行异类任务的局限性
大量相互独立且同类的任务进行并发处理，会将程序的任务量分配到不同的任务中，这样才能获得真正的高性能。

### CompletionService: 当Executor遇到 BlockingQueue
CompletionService结合了Executor和BlockingQueue的功能。可以将callable的任务提交给他执行，然后使用类似于队列中的take和poll的方法，在结果完成时获取这个结果。

### 为任务设置时限
有时候如果一个任务无法在规定时间内完成，那么它的结果就失效了，此时程序可以放弃该活动。在预定的时间内执行任务的主要挑战是：你要确保的到答案，或者发现无法从任务中获得结果这一过程所花费的时间，不会比预定的时间长。

使用限时任务的第二个问题是，当超时后应该能停止他们，这样才不会为继续计算一个无用的结果而浪费资源。为了达到这个目的，可以让任务自己严格管理他的预定时间，超过后就中止执行，或者也可以在超出时限后取消任务。

限时版的invokeAll将多个任务提交到一个ExecutorService，并获得结果。InvokeAll方法处理一个任务的集合，并返回一个Future的集合。2个集合具有相同的结构。**当所有任务都完成时，调用线程被中断或超时，invokeAll都会返回结果。**超时后，任何尚未完成的任务会被取消。作为invokeAll的返回值，每个任务要么正常完成，要么被取消

