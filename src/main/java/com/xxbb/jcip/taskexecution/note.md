# 任务执行 Task Execution
大多数并发应用程序是围绕任务进行管理的。所谓任务就是抽象、离散的工作单元。

## 在线程中执行任务 Executing tasks in thread
围绕执行任务来管理应用程序时，第一步要指明清晰的任务边界。理想状态下，任务是独立的活动，他的工作并不依赖于其他任务的状态、结果或者边界效应。

在正常的负载下，服务器应用程序应具备良好的吞吐量和快速的响应速度。进一步讲，应用程序应该在过载时平缓的劣化，而不是负载一高就简单的以失败告终。为了达到这个目的，你要选择一个清晰的任务边界，并配合一个明确的任务执行策略。

### 顺序执行任务
应用程序内部的任务调度，存在多种可能的调度策略，这些策略可以在不同程度上发挥潜在的并发性。其中最简单的策略是在单一的线程中顺序的执行任务。

对于一个单线程化的服务器，阻塞不仅仅延长了当前请求的完成，而且还阻止了需要被处理的等待请求。如果请求阻塞的时间过长，用户将看不到响应，可能认为服务器已经不可用。同时，单线程在等待他的I/O操作时，CPU会处于闲置状态，导致资源利用率过低。

### 显示的为任务创建线程
为了更好的响应性，可以为每个服务请求创建一个新的线程。

主循环为每个链接创建一个新的线程，而不在主循环内部处理，有3个特点：
1. 执行任务已经脱离主线程，使得主线程可以更快的响应下一个链接。这使得程序可以在前面的请求完成前接收新的请求，从而提高响应性。
2. 并行处理任务，使得多个请求可以同时服务，如果有多个处理器，或者I/O未完成、锁请求以及资源可用性等因素需要阻塞任务时，吞吐量会得到提高。
3. 任务处理代码必须是线程安全的，因为会有多个任务并发的调用。

只要请求的到达速度尚未超出服务器的请求处理能力，那么这种方法可以同时带来更快的响应性和更大的吞吐量。

### 无限创建的缺点
1. 线程生命周期的开销。线程的创建与关闭不是"免费"的。创建线程需要时间，带来请求延迟。如果请求频繁且轻量，就像大多数程序服务器一样，那么每个请求创建一个新的线程的做法会消耗大量的计算资源。
2. 资源消耗量。活动线程会消耗系统资源，尤其是内存。如果可以运行的线程多于可用的处理器数，线程将会限制。大量空闲线程会占用更多内存，给垃圾回收带来压力，大量的线程竞争CPU资源，还会产生其他性能开销。
3. 稳定性。应限制可创建线程的数目。限制的大小视不同平台而定，同时也受到JVM的启动参数，Thread的构造函数中请求的栈的大小等因素，以及底层操作系统的限制。打破这些限制的后果可能会有OOM的错误。

## Executor
任务是逻辑上的工作单元，线程是使任务异步的机制。线程池为管理线程提供了防止程序过载而耗尽内存。

### 执行策略
一个执行策略明确指明了任务执行的"what, where, when, how"，包括：
- 任务在什么线程中执行；
- 任务以什么顺序执行；
- 可以多少个任务并发执行；
- 可以多少个任务进入等待执行队列；
- 如果系统过载，需要放弃一个任务，应该挑选哪个任务？并通知程序知道这一切；
- 任务执行结束前后应该如何处理。

执行策略是资源管理工具。最佳策略资源取决于可用计算资源和对服务质量的需求。通过限制并发数量，确保程序不会由于资源耗尽而失败，大量的任务也不会在争夺稀缺资源时出现性能问题。

### 线程池
在线程池中执行任务线程，比单线程单任务有无可比拟的优势。重用线程资源，而不是创建线程，可以抵消处理请求时线程的创建与消亡产生的开销。另一个好处是，当请求到达时，工作线程通常已经存在，用于创建线程的等待时间并不会延迟任务的执行，提高了响应性。通过调整线程池的参数，动态保持线程池处于忙碌状态，同时防止过多的线程竞争资源，导致内存耗尽。

### Executor声明周期
ExecutorService的生命周期暗含了3种状态：运行（running）、关闭（shutting down）和终止（terminated）。
- ExecutorService被初始化后的处于运行状态。
- shutdown方法会启动一个**平缓的关闭**过程：**停止接收新的任务，并等待已提交的任务完成，包括尚未开始执行的任务。**
- shutdownNow方法会启动一个**强制关闭**的过程：**尝试取消所有运行中的任务和排队中尚未开始的任务。**

一旦所有任务全部完成后，ExecutorService会转入终止状态。可以调用awaitTermination等待ExecutorService到达终止状态，也可以通过isTerminated检查ExecutorService是否终止。

### 延迟且周期性的任务
如果你需要构建自己的调度服务，仍然可以使用了类库提供的DelayQueue，为ScheduledThreadPoolExecutor提供了调度功能。
