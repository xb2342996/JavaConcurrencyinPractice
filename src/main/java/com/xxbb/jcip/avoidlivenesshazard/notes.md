# 避免活跃度危险 Avoiding Liveness Hazards
安全性与活跃度相互牵制，我们使用锁来保证线程安全，但是滥用锁可能引起锁顺序死锁。类似的我们使用线程池和信号量来约束资源的使用，但是却不能知晓那些管辖范围内的活动可能形成的资源死锁。

## 死锁
当一个线程永远占有一个锁，而其他线程尝试去获取这个锁，那么他们将永远被阻塞。当线程A占有锁L时，想要获得锁M，同时线程B占有M，想要获取L，两个线程永远互相等待。

当一个Java线程集发生死锁时，一切都结束了——这些线程永远不能再使用。根据线程完成的不同工作，应用程序可能完全停止或者特定子系统停止，亦可能影响性能。恢复应用程序健康的唯一方式就是中止并重启。

与其他并发危险相同，死锁很少能被独立发现。一个类如果有死锁的潜在可能并不意味着每次都将发生，他只在该发生的时候发生。当死锁出现的时候往往是遇到了最不幸的时候——高负载之下。

### 顺序锁死锁
两个线程试图通过**不同的顺序**获得多个相同的锁。如果锁申请的顺序相同，就不会出现循环的锁依赖现象。
>如果所有线程以通用的固定秩序获得锁，程序就不会出现锁顺序死锁问题了

验证锁顺序一致性需要对程序中锁的行为进行整体分析性。单独观察一个锁的路径是不充分的。当死锁发生时，他们需要知道彼此在做什么。

### 动态的锁顺序死锁
所有线程看起来都是顺序获得锁，但是事实上锁的顺序取决于参数传递的顺序，参数的顺序又取决于外部输入的顺序。

因为参数超出了我们的控制范围，因此我们必须制定锁的顺序，并在整个应用中，获得锁必须始终遵守这个既定的顺序。

只要其中一项考虑时序的地方发生错误，就可能导致程序死锁，而且即使通过了压力测试，也不可能找出所有的潜在的死锁。

### 协作对象间的死锁
获取多重的锁并不总是那么明显，可能不是在同一个方法中请求了两个锁。

调用具有持有锁的外部方法会带来麻烦。外部方法可能会获取其他的锁（产生死锁风险），或者遭遇超时的阻塞，从而使需要你持有该锁的线程停滞不前。

### 开放调用
调用持有锁的外部方法很难分析，因此存在风险。

当调用不需要持有锁的外部方法被称作开放调用。依赖于开放调用的类具备更好的行为，并且比那些需要获得锁的方法相比，更容易与其他类合作。使用开放调用来避免死锁类似于使用封装来保证线程安全：尽管我们能够保证在没有封装的情况下构建线程安全的程序，但是对一个有效封装的类进行线程分析，要比没有封装的类容易的多。

> 在程序中尽量使用开放调用。依赖于开放调用的程序，相比于那些在允许持有锁的情况下调用外部方法的函数，更容易进行死锁自由度的分析。

重构synchronized块有时会使开放调用产生出乎意料的结果，因为他使得一个原子操作变成了非原子操作。有时这样的损失原子性操作是完全可以接受的。不过有时损失操作的原子性是值得关注的。


### 资源死锁
当线程持有和等待的目标变成资源时，同样会发生死锁。

另一种形式的基于资源的死锁是线程饥饿死锁。需要等待其他任务的结果的任务是产生饥饿死锁线程的来源，有界池与相互依赖任务不能放在一起使用。

## 避免和诊断死锁
如果一个程序一次至多只获取一个锁，那么就不会产生死锁。如果你必须获得多个锁，那么锁的顺序设计必须是你工作的一部分，尽量减少潜在的锁之间的交互数量，并遵守文档化的锁协议

### 尝试使用定时锁
另一种监视死锁和从死锁恢复的技术是使用每个显式Lock类中定时tryLock的特性，来代替内部锁机制。在内部锁机制中，只要没有获得锁，就会永远保持，而显示锁使你能够定义超时时间，在规定时间内没有获得锁就返回失败。

### 通过thread-dump分析死锁
JVM使用threaddump来帮助识别死锁的发生。Thread dump包括每个运行中线程的栈追踪信息，以及与之相似并随之发生的异常。Thread Dump也包括锁的信息，比如那个锁由哪个线程构建，其中获得这些锁的栈结构，以及阻塞的线程正在等待那一个锁。

## 其他活跃度危险
### 饥饿
当线程访问它需要的资源却被永久拒绝，以至于不能继续运行，这就发生了饥饿，最常见的饥饿的资源是CPU。在Java应用程序中，使用线程的优先级不当可能引起饥饿。

### 弱响应性
除了饥饿以外另一个问题就是弱响应性，在GUI应用程序中使用后台线程的情况下，这是很常见的。CPU密集型的任务仍然会影响响应性，因为他们会与事件线程共同竞争CPU的微周期。

不良的锁管理也会引起弱响应性。如果一个线程长时间占有一个锁，其他想要访问该容器的线程就必须要等待很长时间。

### 活锁
活锁是线程活跃度失败的另一种形式，尽管没有被阻塞，线程仍然不能继续，因为他不断的重试相同的操作，却总是失败。

解决活锁的方案是对重试机制引入一些随机性。在并发程序中，通过随机等待和撤回来进行重试，能够相当有效的避免活锁的发生。
