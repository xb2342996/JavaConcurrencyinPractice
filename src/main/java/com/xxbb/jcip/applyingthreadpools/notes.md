# 应用线程池 Applying Thread Pools

## 任务与执行策略间的隐性耦合
尽管Executor框架为制定和修改执行提供了相当大的灵活性，但是并非所有的任务都能适合所有的执行策略。有些任务需要明确地指定一个执行策略
- 依赖性任务：多数运行良好的任务都是独立的：他们不依赖于时序，或者其他任务的结果与边界效应。如果你提交给线程池的任务要依赖于其他任务，你就隐式的给执行策略带来了约束，这样你必须小心的管理执行策略，以避免活跃度问题。
- 采用线程限制的任务：单线程化的Executor相比于任意的线程池，可以对同步做出更强的保证。它可以保证线程不被并发的执行，运行你放宽代码对线程安全的要求。可以把对象限制在任务线程中，这使得任务线程所执行的任务在访问对象时，不需要进行同步。这会在任务与执行策略之间形成隐式的耦合——任务需要他们的executor来确保单线程化。
- 对响应时间敏感的任务：GUI应用程序对响应时间是敏感的。将一个长时间运行的任务提交到单线程化的Executor中，或者将多个长时间运行的任务提交给一个只包含少数线程的线程池中，会削弱Executor管理的服务的响应性。
- 使用ThreadLocal的任务：ThreadLocal让每个线程可以保留一份变量的私有版本。但是只要条件允许，Executor就会重用这些线程。只有当本地线程值的声明周期被限定在当前任务中，在池的某些写线程中使用ThreadLocal才有意义：在线程池中，不应该用ThreadLocal传递任务间的数值。

当任务是同类的、独立的时候，线程池才会有最佳的工作表现。如果将耗时的任务与短期的任务混在一起，除非线程池非常大，否则会有"赛车"的风险。

> 一些任务具有这样的特征：需要或者排斥某种特定的执行策略。对其他任务具有依赖性的任务，就会要求线程池足够大，来保证他所依赖的任务不需要排队或者不被拒绝；采用线程限制的任务需要顺序的执行。

### 线程饥饿死锁
在线程池中如果一个任务依赖于其他任务的执行，就可能产生死锁。对于一个单线程化的Executor，一个任务将另一个任务提交到相同的executor中，并等待提交的任务返回结果，这总是会引发死锁。第二个任务停滞在工作队列中，直到第一个任务完成，但是第一个任务不会完成，因为他在等待第二个任务完成。

在一个大的线程池中，如果所有线程执行的任务都阻塞在线程池中，等待着仍然处于同一队列中的其他任务，那么就会发生同样的问题，这被称作线程饥饿死锁。满足下述就会发生：
<br>只要池任务开始了无限阻塞，其目的是等待一些资源或者条件，此时只有另一个池的活动才能使那些条件成立。除非能保证线程池足够大，否则会发生线程饥饿死锁。

### 耗时操作
如果任务因为过长的时间周期而阻塞，那么即使不可能出现死锁，线程池的响应速度也会变得很差。耗时任务会造成线程池阻塞，还会拖长服务时间， 即使小的任务也难以幸免。

缓解耗时操作带来影响的一个办法是限定任务等待资源的时间，而不是无限制的等待下去。如果等待超时，可以把任务标记为失败，终止或者把他重新加入队列，准备之后执行。这样无论任务的最终结果是成功还是失败，该办法都保证了任务总会向前发展，这样可以更快的将任务从线程中解放出来。如果线程池频频被阻塞的线程充满，这同样也是线程池太小的一个信号。

## 定制线程池的大小
线程池的合理长度取决于未提交的任务类型和所部署的操作系统的特征。很少有人会把线程池的长度进行硬编码，池的长度应该是由某些动态机制来提供，或者利用Runtime.availiableProcessors的结果，动态的计算。

你只需要做到避免"过大"和"过小"两种极端情况。如果线程池过大，那么线程对稀缺的CPU和内存的竞争，会导致内存使用率过高，还可能耗尽资源。如果过小，由于存在很多可用的处理器资源却未工作，会对吞吐量造成损失。

- 对于计算密集型的任务，一个有N个处理器的系统通常使用N+1个线程的线程池来获取最好的利用率。
- 对于I/O密集型任务，不是所有的线程都会在所有的时间被调度，因此你需要一个更大的池。为了正确设置这个池的长度，你必须估算出任务花在调度上的等待时间与你用来计算的时间的比率

## 配置ThreadPoolExecutor