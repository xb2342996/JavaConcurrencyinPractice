# 应用线程池 Applying Thread Pools

## 任务与执行策略间的隐性耦合
尽管Executor框架为制定和修改执行提供了相当大的灵活性，但是并非所有的任务都能适合所有的执行策略。有些任务需要明确地指定一个执行策略
- 依赖性任务：多数运行良好的任务都是独立的：他们不依赖于时序，或者其他任务的结果与边界效应。如果你提交给线程池的任务要依赖于其他任务，你就隐式的给执行策略带来了约束，这样你必须小心的管理执行策略，以避免活跃度问题。
- 采用线程限制的任务：单线程化的Executor相比于任意的线程池，可以对同步做出更强的保证。它可以保证线程不被并发的执行，运行你放宽代码对线程安全的要求。可以把对象限制在任务线程中，这使得任务线程所执行的任务在访问对象时，不需要进行同步。这会在任务与执行策略之间形成隐式的耦合——任务需要他们的executor来确保单线程化。
- 对响应时间敏感的任务：GUI应用程序对响应时间是敏感的。将一个长时间运行的任务提交到单线程化的Executor中，或者将多个长时间运行的任务提交给一个只包含少数线程的线程池中，会削弱Executor管理的服务的响应性。
- 使用ThreadLocal的任务：ThreadLocal让每个线程可以保留一份变量的私有版本。但是只要条件允许，Executor就会重用这些线程。只有当本地线程值的声明周期被限定在当前任务中，在池的某些写线程中使用ThreadLocal才有意义：在线程池中，不应该用ThreadLocal传递任务间的数值。

当任务是同类的、独立的时候，线程池才会有最佳的工作表现。如果将耗时的任务与短期的任务混在一起，除非线程池非常大，否则会有"赛车"的风险。

> 一些任务具有这样的特征：需要或者排斥某种特定的执行策略。对其他任务具有依赖性的任务，就会要求线程池足够大，来保证他所依赖的任务不需要排队或者不被拒绝；采用线程限制的任务需要顺序的执行。

### 线程饥饿死锁
在线程池中如果一个任务依赖于其他任务的执行，就可能产生死锁。对于一个单线程化的Executor，一个任务将另一个任务提交到相同的executor中，并等待提交的任务返回结果，这总是会引发死锁。第二个任务停滞在工作队列中，直到第一个任务完成，但是第一个任务不会完成，因为他在等待第二个任务完成。

在一个大的线程池中，如果所有线程执行的任务都阻塞在线程池中，等待着仍然处于同一队列中的其他任务，那么就会发生同样的问题，这被称作线程饥饿死锁。满足下述就会发生：
<br>只要池任务开始了无限阻塞，其目的是等待一些资源或者条件，此时只有另一个池的活动才能使那些条件成立。除非能保证线程池足够大，否则会发生线程饥饿死锁。

### 耗时操作
如果任务因为过长的时间周期而阻塞，那么即使不可能出现死锁，线程池的响应速度也会变得很差。耗时任务会造成线程池阻塞，还会拖长服务时间， 即使小的任务也难以幸免。

缓解耗时操作带来影响的一个办法是限定任务等待资源的时间，而不是无限制的等待下去。如果等待超时，可以把任务标记为失败，终止或者把他重新加入队列，准备之后执行。这样无论任务的最终结果是成功还是失败，该办法都保证了任务总会向前发展，这样可以更快的将任务从线程中解放出来。如果线程池频频被阻塞的线程充满，这同样也是线程池太小的一个信号。

## 定制线程池的大小
线程池的合理长度取决于未提交的任务类型和所部署的操作系统的特征。很少有人会把线程池的长度进行硬编码，池的长度应该是由某些动态机制来提供，或者利用Runtime.availiableProcessors的结果，动态的计算。

你只需要做到避免"过大"和"过小"两种极端情况。如果线程池过大，那么线程对稀缺的CPU和内存的竞争，会导致内存使用率过高，还可能耗尽资源。如果过小，由于存在很多可用的处理器资源却未工作，会对吞吐量造成损失。

- 对于计算密集型的任务，一个有N个处理器的系统通常使用N+1个线程的线程池来获取最好的利用率。
- 对于I/O密集型任务，不是所有的线程都会在所有的时间被调度，因此你需要一个更大的池。为了正确设置这个池的长度，你必须估算出任务花在调度上的等待时间与你用来计算的时间的比率

## 配置ThreadPoolExecutor
如果默认的执行策略不满足需求，可以通过构造函数实例化一个ThreadPoolExecutor，自定义参数。

### 线程的创建与销毁
核心池数量（core pool size）、最大池数量（max pool size）和存活时间（keep-alive time）共同管理着线程的创建与销毁。
- 核心池数量是目标的数量，即使没有任务在执行，线程池的实现也会维持池在这个容量，并且直到工作队列充满之前，都不会创建新的线程。
- 最大池数量是可同时活动的线程数的上限。
- 如果一个线程已经限制的时间超过了存活时间，它将被回收成为一个候选者，如果当前池的数量超过了核心池数量，线程会被线程池终止。

通过调节核心数量和存活时间，可以促进线程池归还空闲线程占有的资源，让这些资源可用于更有用的工作。

### 管理队列任务
有限的线程池可以限制并发任务的数量。

如果新的请求到达的频率超过了线程池能够处理他们的速度，请求将在队列中等候。有了线程池，这些多出来的请求会在一个由Executor管理的Runnable队列中等待，而不是作为竞争CPU资源的线程队列。

即使通常平均请求速率都很稳定，也难免会突然激增。尽管队列有助于缓和瞬时的任务激增，但是如果任务持续快速，最终还是要遏制请求速率，以避免内存耗尽。即使没有内存耗尽，响应时间也会随着队列任务的增长而逐渐便变慢。

一个稳妥的资源管理策略是使用有限队列。对于一个有限队列，队列的长度必须和池的长度一起调节。一个大队列加一个小池，可以控制CPU和内存的使用，还可以减少上下文的切换，但是要接受潜在的吞吐量约束的开销。

对于庞大或者无线的线程池，可以使用SynchronousQueue，完全绕开队列，将任务直接从生产者移交给工作线程。SynchronousQueue并不是一个真正的队列，而是管理直接在线程间移交信息的机制。将一个元素放入到SynchronousQueue中必须有另一个线程在等待任务。如果没有这个线程，只要当前池数量小于最大池数量，Executor会创建一个新的线程，否则根据拒绝策略，任务被拒绝。

只有当任务彼此独立时，才能使用有限线程池或者有限工作队列。假如线程之间互相依赖，有限的线程池就会引起线程饥饿死锁。

### 拒绝策略
当一个有限队列充满之后，决绝策略开始生效。

JDK提供了4种拒绝策略：
默认的中止策略（AbortPolicy）：引起execute抛出未检查的RejectedExecutionException；调用者捕获这个异常，然后编写满足自己需求的处理代码。
遗弃（DiscardPolicy）：默认放弃这个任务
遗弃最久的（DiscardOldestPolicy）：选择丢弃的任务是接下来就应该执行的，该策略还会尝试重提交新任务。
调用者运行（CallerRunsPolicy）：既不丢弃哪个任务，也不会抛出任何异常。他会把一些任务推回到调用者那里，已减缓新任务的流。他不会在线程池中执行最新提交的任务，但是会在一个调用executor的线程中执行。

### 线程工厂
无论何时，线程池需要创建一个线程，都要通过一个线程工厂来完成。默认的线程工厂创建一个新的，非后台的线程，并没有特殊配置。

### 构造后再定制ThreadPoolExecutor
大多数通过构造函数传递给线程的参数都可以在创建后通过setters进行修改。如果Executor是通过Executors中的某一个工厂方法创建出来的，首先将类型转化为ThreadPoolExecutor然后在通过setters方法。

## 拓展ThreadPoolExecutor
ThreadPoolExecutor提供了几个函数让子类去复写——beforeExecute、afterExecute、terminated。

执行任务的线程都会调用函数beforeExecute和afterExecute，用他们去添加日志，时序，监视器或者统计信息收集的功能。

terminated会在线程池完成关闭动作后调用，也就是当所有任务都完成并且所有的工作线程也已经关闭后，会执行terminated。terminated可以用作释放Executor在生命周期中分配到的资源，还可以发送通知，记录日志或者完成统计信息。

当每个迭代彼此独立，并且在循环主体的每个迭代中完成的工作足以抵消管理新任务的成本时，顺序循环迭代适合于并行化。
