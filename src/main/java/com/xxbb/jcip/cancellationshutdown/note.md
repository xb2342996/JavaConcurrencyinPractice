# 取消与关闭
启动一个线程与任务非常容易，有时我们希望线程或任务自然结束之前就停止，因为用户取消了操作或应用程序提前关闭。

要做到安全，快速，可靠的停止任务或线程并不容易。**Java没有提供这种机制，来安全地强迫停止手头的工作。它提供一个中断——一个协作机制，使一个线程能够要求另一个线程停止当前的工作。**
这种协作是必须的。因为我们很少需要一个任务，线程或服务立即停止，立即停止可能会导致共享数据结构状态处于不一致状态。

## 任务取消 Task Cancellation
当外部代码能够在活动自然完成之前，把他的状态改成完成状态，那么整个活动被称为可取消的。我们可能因为很多原因取消一个活动：
- 用户请求的取消
- 限时活动
- 应用程序事件
- 错误
- 关闭

在Java中没有哪一种停止线程的方式是绝对安全的，因此没有哪一种方式优先用来停止任务。只有通过相互协作的机制，使任务和代码遵循一个统一的协议用来请求取消。

### 中断
每一个线程都有一个boolean类的中断状态，在中断的时候，这个中断被设置为true。Thread包含其他用于中断的方法，以及请求线程中断的状态。interrupt方法中断目标线程，并且isInterrupt返回当前目标的中断状态。JVM并没有对阻塞方法发现中断的速度进行保证，不过现实中响应速度还是比较迅速的。

当线程在并不处于阻塞状态的情况下发生中断时，会设置线程的中断状态，然后一直等到被取消的活动获取中断状态，来检查是否发生了中断。
> 调用interrupt并不意味着必然停止目标线程正在进行的工作，它仅仅传递了请求中断的信息。

对中断最好的理解是：它并不会真正的中断一个正在运行的线程；它仅仅是发出中断请求，线程自己会在下一个方便中断的时刻进行中断。
> 中断通常是实现取消最明智的选择。

### 中断策略
一个中断策略决定线程如何应对中断请求——发现中断请求时，它会做什么，那些工作单元对于中断来说是原子操作，以及多块的时间里响应中断。

中断策略中最有意义的是对线程级（thread level）和服务级（service level）取消的规定：尽可能迅速退出，如果需要的话进行清理，可能的话通知其他拥有的实体，这个线程已经退出。

区分任务和线程中断的反应是很重要的。一个单一的中断请求可能有一个或一个以上预期的接收者——在线程池中中断一个工作者线程，意味着取消当前任务并关闭工作线程。

任务不会在自己拥有的线程中执行，他们借用属于服务的线程，比如线程池。代码如果不是线程的所有者，就应该小心保存中断状态，这样所有的代码才能最终对其起到作用。

当检查中断请求时，任务并不需要放弃所有事情——它可以选择推迟，直到更合适的时机。这需要记得它已经被请求过中断的状态，完成当前正在执行的任务，然后抛出InterruptedException或指明中断。当更新的过程中发生中断时，这项技术能够保证数据结构不被破坏。

一个任务不应该假设其执行线程的中断策略，除非显示的设计用来运行在服务中，并且这些操作有明确的中断策略。无论任务把中断解释为取消，还是其他一些关于中断的操作，它都应该注意保存执行线程的中断状态。如果中断的处理不仅仅是把InterruptedException传递给调用者，那么它应该在捕获异常后恢复中断的状态：Thread.currentThread().interrupt()。

线程只能被线程的所有者中断，所有者把线程的中断策略信息封装到一个合适的取消机制中。因为每一个线程都有自己的中断策略，所以你不应该中断线程，除非你知道中断对这个线程意味着什么。

### 响应中断
当你调用可中断的阻塞函数时，比如Thread.sleep()或者BlockingQueue.put()，有两种处理办法:
- 传递异常，是你的方法称为可中断的阻塞方法；
- 保存中断状态，上层调用栈能够对其进行处理。

> 只有实现了线程中断策略的代码才可以接收中断请求。通用目的的任务和库的代码不应该接收中断请求。

有一些活动不支持取消，却仍可能调用中断的阻塞方法，那么他必须在循环中调用这些方法，当发现中断后重新尝试。过早的设置中断可能会引起无限循环，因为大多数可中断的阻塞方法在入口时检查中断状态，并且如果该状态已设置，那么可能抛出InterruptException。

### 处理不可中断阻塞
并不是所有的阻塞方法或阻塞机制都响应中断；如果一个线程是有同步Socket I/0或者等待获得内部锁而阻塞的，那么中断除了能够设置线程中断状态外，什么都不能改变。对于这些不可被中断的活动所阻塞的线程，我们可以使用与中断类似的手段，来确保这些线程可以安全停止。

## 停止基于线程的服务
应用程序通常会创建拥有线程的服务，比如线程池，这些服务的存在时间通常比创建他们的方法存在时间长。如果应用程序优雅的退出，这些服务的线程也需要结束。因为没有退出线程的惯用方法，他们需要自行结束。

认为线程有一个对应的拥有者是有道理的，这个拥有者就是创建这个线程的类，所以线程池拥有他的工作线程，如果需要中断这些线程，那么应该由线程池负责。

正如其他被封装的对象一样，线程的所有权是不可传递的，应用程序可能拥有服务，服务可能拥有工作线程，但是应用程序并不拥有工作线程，因此应用程序不应该试图关闭工作线程。相反，服务应该提供声明周期方法，来关闭自己，并且关闭他拥有的所有线程。

> 对于线程持有的服务，只要服务的存在时间大于创建线程方法存在的时间，那么就应该提供生命周期方法。

### 关闭ExecutorService
ExecutorService提供了2中关闭的方法：shutdown优化的关闭和shutdownNow强制关闭。

两种不同的终结选择在安全性与响应性之间做了平衡：强行终结的速度更快，但是风险大，因为任务很可能执行到一半就被强行终结，而正常终结虽然很慢，却很安全，因为直到队列中的所有任务完成前，ExecutorService都不会关比

### 致命💊
另一种保证消费者与生产者服务关闭的方式是使用Poison Pill：一个可识别的对象置于队列中，意味着当你得到他时，停止一切工作。在先进先出队列中，致命药丸保证了消费者队列中关闭之前完成所有的任务，因为早于药丸提交的的工作会在处理他之前完成。

### shutdownNow的局限性
当使用shutdownNow强制关闭一个ExecutorService时，它试图取消正在执行的任务，并返回那些已经提交但是还未开始的任务的清单。然而我们没有任何一个常规的方法去找出那些已经开始却没有结束的任务，这意味着我们不可能在关闭时知道进行中的任务的状态，除非任务本身设立了某些检查点。为了获取那些任务没有结束，你不仅需要知道那些任务还没开始，而且还应知道Executor关闭时，那些任务正在进行中。
