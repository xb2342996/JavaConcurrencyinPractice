# 取消与关闭
启动一个线程与任务非常容易，有时我们希望线程或任务自然结束之前就停止，因为用户取消了操作或应用程序提前关闭。

要做到安全，快速，可靠的停止任务或线程并不容易。**Java没有提供这种机制，来安全地强迫停止手头的工作。它提供一个中断——一个协作机制，使一个线程能够要求另一个线程停止当前的工作。**
这种协作是必须的。因为我们很少需要一个任务，线程或服务立即停止，立即停止可能会导致共享数据结构状态处于不一致状态。

## 任务取消 Task Cancellation
当外部代码能够在活动自然完成之前，把他的状态改成完成状态，那么整个活动被称为可取消的。我们可能因为很多原因取消一个活动：
- 用户请求的取消
- 限时活动
- 应用程序事件
- 错误
- 关闭

在Java中没有哪一种停止线程的方式是绝对安全的，因此没有哪一种方式优先用来停止任务。只有通过相互协作的机制，使任务和代码遵循一个统一的协议用来请求取消。

### 中断
每一个线程都有一个boolean类的中断状态，在中断的时候，这个中断被设置为true。Thread包含其他用于中断的方法，以及请求线程中断的状态。interrupt方法中断目标线程，并且isInterrupt返回当前目标的中断状态。JVM并没有对阻塞方法发现中断的速度进行保证，不过现实中响应速度还是比较迅速的。

当线程在并不处于阻塞状态的情况下发生中断时，会设置线程的中断状态，然后一直等到被取消的活动获取中断状态，来检查是否发生了中断。
> 调用interrupt并不意味着必然停止目标线程正在进行的工作，它仅仅传递了请求中断的信息。

对中断最好的理解是：它并不会真正的中断一个正在运行的线程；它仅仅是发出中断请求，线程自己会在下一个方便中断的时刻进行中断。
> 中断通常是实现取消最明智的选择。

### 中断策略
一个中断策略决定线程如何应对中断请求——发现中断请求时，它会做什么，那些工作单元对于中断来说是原子操作，以及多块的时间里响应中断。

中断策略中最有意义的是对线程级（thread level）和服务级（service level）取消的规定：尽可能迅速退出，如果需要的话进行清理，可能的话通知其他拥有的实体，这个线程已经退出。

区分任务和线程中断的反应是很重要的。一个单一的中断请求可能有一个或一个以上预期的接收者——在线程池中中断一个工作者线程，意味着取消当前任务并关闭工作线程。

任务不会在自己拥有的线程中执行，他们借用属于服务的线程，比如线程池。代码如果不是线程的所有者，就应该小心保存中断状态，这样所有的代码才能最终对其起到作用。

当检查中断请求时，任务并不需要放弃所有事情——它可以选择推迟，直到更合适的时机。这需要记得它已经被请求过中断的状态，完成当前正在执行的任务，然后抛出InterruptedException或指明中断。当更新的过程中发生中断时，这项技术能够保证数据结构不被破坏。

一个任务不应该假设其执行线程的中断策略，除非显示的设计用来运行在服务中，并且这些操作有明确的中断策略。无论任务把中断解释为取消，还是其他一些关于中断的操作，它都应该注意保存执行线程的中断状态。如果中断的处理不仅仅是把InterruptedException传递给调用者，那么它应该在捕获异常后恢复中断的状态：Thread.currentThread().interrupt()。

线程只能被线程的所有者中断，所有者把线程的中断策略信息封装到一个合适的取消机制中。因为每一个线程都有自己的中断策略，所以你不应该中断线程，除非你知道中断对这个线程意味着什么。

### 响应中断
当你调用可中断的阻塞函数时，比如Thread.sleep()或者BlockingQueue.put()，有两种处理办法:
- 传递异常，是你的方法称为可中断的阻塞方法；
- 保存中断状态，上层调用栈能够对其进行处理。

> 只有实现了线程中断策略的代码才可以接收中断请求。通用目的的任务和库的代码不应该接收中断请求。

有一些活动不支持取消，却仍可能调用中断的阻塞方法，那么他必须在循环中调用这些方法，当发现中断后重新尝试。过早的设置中断可能会引起无限循环，因为大多数可中断的阻塞方法在入口时检查中断状态，并且如果该状态已设置，那么可能抛出InterruptException。

### 处理不可中断阻塞
并不是所有的阻塞方法或阻塞机制都响应中断；如果一个线程是有同步Socket I/0或者等待获得内部锁而阻塞的，那么中断除了能够设置线程中断状态外，什么都不能改变。对于这些不可被中断的活动所阻塞的线程，我们可以使用与中断类似的手段，来确保这些线程可以安全停止。

## 停止基于线程的服务
应用程序通常会创建拥有线程的服务，比如线程池，这些服务的存在时间通常比创建他们的方法存在时间长。如果应用程序优雅的退出，这些服务的线程也需要结束。因为没有退出线程的惯用方法，他们需要自行结束。

认为线程有一个对应的拥有者是有道理的，这个拥有者就是创建这个线程的类，所以线程池拥有他的工作线程，如果需要中断这些线程，那么应该由线程池负责。

正如其他被封装的对象一样，线程的所有权是不可传递的，应用程序可能拥有服务，服务可能拥有工作线程，但是应用程序并不拥有工作线程，因此应用程序不应该试图关闭工作线程。相反，服务应该提供声明周期方法，来关闭自己，并且关闭他拥有的所有线程。

> 对于线程持有的服务，只要服务的存在时间大于创建线程方法存在的时间，那么就应该提供生命周期方法。

### 关闭ExecutorService
ExecutorService提供了2中关闭的方法：shutdown优化的关闭和shutdownNow强制关闭。

两种不同的终结选择在安全性与响应性之间做了平衡：强行终结的速度更快，但是风险大，因为任务很可能执行到一半就被强行终结，而正常终结虽然很慢，却很安全，因为直到队列中的所有任务完成前，ExecutorService都不会关比

### 致命💊
另一种保证消费者与生产者服务关闭的方式是使用Poison Pill：一个可识别的对象置于队列中，意味着当你得到他时，停止一切工作。在先进先出队列中，致命药丸保证了消费者队列中关闭之前完成所有的任务，因为早于药丸提交的的工作会在处理他之前完成。

### shutdownNow的局限性
当使用shutdownNow强制关闭一个ExecutorService时，它试图取消正在执行的任务，并返回那些已经提交但是还未开始的任务的清单。然而我们没有任何一个常规的方法去找出那些已经开始却没有结束的任务，这意味着我们不可能在关闭时知道进行中的任务的状态，除非任务本身设立了某些检查点。为了获取那些任务没有结束，你不仅需要知道那些任务还没开始，而且还应知道Executor关闭时，那些任务正在进行中。

## 处理反常的线程终止
导致线程死亡的主要原因是RuntimeException。因为这些异常表明一个程序错误或其他不可修复的错误，它通常是不能被捕获的。它们不会顺着栈的调用传递，此时，默认的行为是在控制台打印栈追踪的信息，并终止线程。

### 未捕获的异常处理
当一个线程因为未捕获的异常退出时，JVM会把这个时间报告给应用程序提供的UncaughtExceptionHandler；如果处理器不存在，默认行为是想System.err打印出栈追踪信息。

> 在一个长时间运行的应用程序中，所有的线程都要给未捕获异常设置一个处理器，这个处理器至少要将异常信息记录日志中。

## JVM关闭
JVM可以通过正常手段关闭，也可以强行关闭。当最后一个正常线程终结时，或者有人调用了System.exit，以及通过使用其他与平台相关的手段时，都可以开始一个正常的关闭。

### 关闭钩子
在正常关闭中，JVM首先启动所有已注册的Shutdown hook。JVM不能保证关闭钩子的顺序。如果关闭应用程序时，他仍在运行，他们接下来将与关闭进程并发执行。当所有关闭钩子结束的时候，如果runFinalizersOnExit为true，JVM可以选择运行finalizer，之后停止。JVM不会尝试中断或者停止任何关闭时仍然在运行的应用程序线程，它们在JVM终止时被强制退出。如果关闭钩子或finalizer没有完成，那么正常的关闭进程"挂起"，并且JVM必须强行执行关闭。在强行关闭的过程中，JVM不需要完成除了关闭JVM以外的任何事情，不会运行关闭钩子。

关闭钩子应该是线程安全的：他们在访问共享数据时必须同步，并应该小心的避免死锁。

### 守护线程
当你需要创建一个线程，辅助执行一些工作，但是你不希望这个线程阻碍JVM的关闭，这时需要用到守护线程。

线程被分为两种：普通线程与守护线程。JVM启动时所创建的线程除了主线程以外，其他的都是守护线程。

普通线程与守护线程的区别仅仅在于退出时会发生什么。当一个线程退出时，JVM会检查一个运行中线程的详细清单，如果仅剩下守护线程，它会发起正常的退出。当JVM停止时，所有仍然存在的守护线程都会被抛弃——不执行finally块，也不会释放栈——JVM直接退出。

### Finalizer
避免使用finalizer

