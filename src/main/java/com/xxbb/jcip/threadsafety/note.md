# 线程安全 Thread Safety
线程安全的本质是对状态访问的管理，通常都是可变的、共享的状态。<br>
**线程安全真正要做的是在不可控的并发访问中保护数据的状态。**
- 共享：指一个变量可以被多个线程访问
- 可变：变量的值在生命周期内可变

一个对象是否是线程安全的取决于他是否会被多个线程访问，进而取决于程序如何使用对象。保证对象线程安全需要使用同步来协调对其可变状态的访问

## 什么是线程安全性
一个类是线程安全的是指在被多个线程访问的情况下，类可以持续的进行正确的行为。<br>
当多个线程访问一个类时，不考虑线程在调度环境下的调度与交替执行，也不需要进行额外的同步和协调，这个类的行为依然是正确的，这个类被称作线程安全的。


>无状态(stateless)的线程永远是安全的。比如绝大多数不记录状态的servlet

## 原子性 Atomic
### 竞争条件
当计算的正确性依赖于运行时的时序或者多线程的交替时，会产生竞争条件。<br>
- 最常见的竞争条件是"check-then-act"，使用一个潜在的过期值作为下一步操作的依据。一个最常见的check-then-act操作是lazy initialization。<br>
- 另一种竞争条件"read-modify-write"，他按照对象先前使用的状态来定义对象的状态转换，你必须先知道先前值并确保你在更新的过程中，没有其他线程修改这个值

竞争条件并不总是导致失败，需要某些特定的时刻。

### 复合操作
相对于统一状态下的其他操作而言，必须是原子性的。为了避免竞争条件，必须阻止其他线程访问我们正在修改的变量，以确保当其他线程想要查看或者修改一个状态时，必须在我们
的线程开始或结束之后，而不能在操作之中。

## 🔐 Lock
当一个不变约束涉及多个变量时，变量之间不是彼此独立的，某个变量的值会约束其他几个变量的值，因此更新一个变量时，要再同一原子操作中更新其他几个。
> 为了保护状态的一致性，要在单一的原子操作中更新互相关联的状态变量

### 内部🔐 synchronized
每个Java对象都可以隐式的扮演一个内部锁的角色——被称作内部锁（intrinsic lock)或监视锁（monitor lock）。执行synchronized代码块之前会自动获取锁，无论正常或异常退出，线程会在结束控制synchronized代码块控制时自动释放锁。
> 获取内部锁的唯一途径：进入这个内部锁保护的同步块或方法

内部锁在Java中扮演互斥锁的角色，意味着至多只能有一个线程可以拥有这个锁。如果一个线程不释放锁，另一个线程永远等待下去。

### 可重入 reentrancy
当一个线程请求其他线程已经占有的锁时，请求线程将被阻塞。然而内部锁是可重入的，当一个线程在请求它锁自己获取的锁时，会成功获取锁。

可重入意味着所有的请求是基于线程的而不是基于调用的。

>实现方式：通过每个锁关联一个请求计数器和他占有的线程，当计数器为0时，认为锁未占有。同一线程请求计数器+1，线程退出计数器-1，计数器为0时，锁被释放。

### 带🔐的保护状态 guarding with lock
如果用同步来协调访问变量，每次访问变量时都需要同步。换句话来说，用锁来协调访问变量时，每次访问都要用同一个锁。
>一种常见的错误观念认为只有写入共享变量时才需要同步；事实并非如此

对象的内部锁与他的状态之间没有直接的内在关系。即使获得了与对象关联的内部锁也不能阻止其他线程访问对象——获取对象的锁后，唯一可以做的事是阻止其他线程在获得相同的锁。
<br>并不是所有的数据都需要锁的保护，只有那些会被多个线程访问的可变数据。
<br>锁保护的变量意味着每一次访问变量时都要获取该锁，确保在同一时刻只有一个线程可以访问这个变量。若类的不变约束涉及多个状态变量，那么还需要添加另外一个附加需求：每个参与到不变约束的变量由同一个锁守护。

### 活跃度与性能 performance and liveness
通常复杂度与性能之间是相互牵制的。实现一个同步策略时，不要过早的为了性能而牺牲简单性（这是对安全性的妥协）。
<br>无论是做计算密集型操作，还是执行一个可能存在潜在阻塞风险的操作，如果线程长时间的占有锁，会引发活跃度与性能风险的问题。


