# 共享对象 Sharing Objects
synchronized关键字不仅可以阻塞线程执行，确保原子化的操作执行，同时还具有内存可见性的功能。
<br>我们希望一个线程对对象的状态进行修改过后，其他的线程能够看到真正的改变，这就需要同步机制。

## 可见性 Visibility
为了保证跨线程写入的内存可见性，必须使用同步机制。
> 在没有同步的情况下，编译器，处理器，运行时会对操作的执行顺序做一些奇怪的事。在未同步的情况下，尝试去判断一些必然在内存中发生的动作，通常是错误的。

只要数据需要被跨线程共享，就进行恰当的同步。

### 过期数据 stale data
除非每一次访问变量都是同步的，否则很可能得到变量的过期值。更坏的情况是，过期既不会发生在全部变量上，也不会完全不出现；一个线程可能会得到一个变量最新的值，也有可能是另一个变量之前写入的过期值。
<br>过期的数据可能会使对象引用中的数据更加复杂，比如链表中指针的实现。过期数据还会引起更严重且混乱的错误，比如意外的异常，脏的数据，错误的计算和无限的循环。

### 非原子性的64位操作 Nonatomic 64-bit operations
没有被volatile修饰的64位数值变量（long和double），如果读写发生在不同的线程，读取一个非volatile类型的long就可能会读到一个高32位的值和另外一个低32位的值。
<br>解决办法：声明volatile类型或者用锁保护。

### 锁与可见性 locking and visibility
当访问一个共享变量时，所有线程都使用同一个锁进行同步，为了保证一个线程对数值进行的写入，对其他线程都可见。如果一个线程在没有恰当的使用锁的情况下读取变量，那么这个变量很有可能是一个过期的数据。
<br>锁不仅仅是关于同步与互斥，也关于内存可见的。为了保证**所有线程**都能够看到共享的，可变变量的**新值**，**读取**和**写入线程**都必须使用**公共的锁**进行同步

### Volatile变量 volatile variables
Java语言同时提供了另一种弱同步的形式：**volatile**，确保一个变量的更新可以以预见的方式告知其他线程。
<br>当一个域被声明为volatile时， 编译器与运行时会监视这个变量，并且它的操作不会与其他内存操作进行重排序，volatile变量不会缓存在寄存器或者缓存在其他处理器隐藏的地方，所以读取一个volatile类型的变量，总会返回由某个线程写入的最新值。
<br>访问volatile变量的操作不会加锁，也就不会阻塞执行的线程，相对synchronized而言，volatile是一个轻量级的同步机制。

volatile固然方便，但是同时也有一定的限制，他通常被当做标识**完成，中断，状态**的标记使用。
>加锁可以保证可见性和原子性，volatile变量只能保证可见性<br>

<br>满足以下所有标准后，才可使用volatile变量：
 - 写入变量不依赖变量的当前值，或者确保只有单一线程修改变量的值；
 - 变量不需要与其他状态变量共同参与不变约束；
 - 访问变量时，没有其他原因需要加锁。
 
## 发布与逃逸 Publication and Escape
**发布（publishing）**：将一个对象发布意味着该对象能被当前范围之外的代码使用。很多情况下，我们需要确保对象及他们的内部状态不被暴露，但是有些情况下，为了正当的使用目的，我们又确实希望发布一个对象。
<br>**逃逸（Escape）**：一个对象在尚未准备好的情况下就将它发布，这种情况被称为逃逸。 
其他线程利用发布的引用做什么并不重要，因为无论如何，被无用的风险都是存在的。一旦一个对象逸出，你就要假设存在其他类或者线程可能会误用他。
> 解决办法：封装——封装使得程序的正确性分析变得更可行，更不容易偶然的破坏设计约束。

### 安全构建
> 不要让this引用在构造期间逃逸。

一个导致this在构造期间逃逸的常见错误，是在构造期间启动线程。当对象在构造函数中创建一个线程时，无论显式或隐式的，this引用几乎总是被新线程共享的，于是新线程在构造完成前就可以看见他。在构造函数中创建线程并没有错，但是不能立即启动他。使用一个start或initialize方法来启动对象拥有的线程。

## 线程封闭 Thread Confinement
访问共享，可变的数据要求线程同步。一个避免线程同步的方法就是不共享数据。如果数据仅在单线程中被访问，就不需要任何同步。
<br>线程封闭技术是实现线程安全最简单的办法之一。当对象被封闭在一个线程中，这种做法会自动成为线程安全的。

### Ad-hoc线程限制
Ad-hoc线程限制：是指维护线程限制性的任务全部落在实现上的情况。
<br>由于没有可见性修饰与本地变量等语言特性协助将对象限制在目标线程上，所以这种方式非常容易出错。
<br>鉴于ad-hoc线程限制的固有易损性，可以用栈限制或ThreadLocal取代它。

### 栈限制
栈限制是线程限制的一个特例，在栈限制中，只能通过本地变量才能访问对象。本地变量本身就被限制在执行线程中，他们存在于执行线程栈。

### ThreadLocal
ThreadLocal是维护线程限制更规范的一种方式，他允许你讲线程与持有数据的对象单独关联在一起。每个线程维护一份单独的拷贝，所以每次get总是返回最新的set值。
<br>ThreadLocal变量通常用于防止在基于可变的单体或全局变量的设计，出现（不正确的）共享。

## 不可变性 Immutability
创建后状态不能被修改的对象叫做不可变对象。**不可变对象天生就是线程安全的**。它们的常量是在构造函数中创建的。既然它们的状态都无法修改，这些常量永远不会变。

- 不可变对象是简单的。它们只有一种状态，构造函数严谨地控制着这个状态。
- 不可变对象也是安全的。不可变对象不会被恶意的或被漏洞百出的代码破坏，可以放心的发布和共享，不需要创建防御性拷贝。

Java没有对不可变性的正确定义，不可变性不是简单的等于将所有的域都声明成final类型，所有域都是final类型的变量依然可以使可变的，因为final域可以**获得一个到可变对象的引用**。
只有满足以下状态的一个对象才是不可变的：
- 他的状态不能在被创建后修改；
- 他的所有域都是final类型；
- 创建期间没有发生this引用逃逸。

### Final域 Final field
final域是不可修改的（尽管如果final域指向的对象是可变得，这个域仍然可以被修改）。使用final确保线程可以被初始化的安全性（initialization safety），初始化安全性使得不可变对象可以在没有同步的情况下自由的被访问和共享。
> 将所有的域声明为final型，除非他是可变的。

## 安全发布 Safe Publication
由于可见性的问题，容器还是会在其他线程中被设置一个不一致的状态，即使他的不变约束在构造函数中得以正确创建

### 不可变对象与初始化安全性
对象的引用对其他线程可见，并不意味着对象的状态一定对消费线程可见。为了保证对象状态有一个一致性视图，我们需要同步。
<br>即使发布对象引用时没有使用同步，不变对象仍然可以被安全访问。为了获取这种初始化安全性的保证，应该满足所有不可变性的条件。
>不可变对象在没有额外同步的情况下，安全的用于任意线程，甚至发布他时也不需要同步。

### 安全发布的模式
如果一个对象不是不可变的，它必须被安全的发布，通常发布线程与消费线程必须同步化。
> 为了安全的发布对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确创建的对象可以用过下列条件安全的发布：
> - 通过静态初始化器初始化对象的引用
> - 将它的引用存储到volatile域或者AutomicReference
> - 将他的引用存储到正确创建的对象的final域中
> - 或者将它的引用存储到由锁保护的域中

### 有效不可变对象
安全发布足以使其他线程安全地访问发布后无需另外同步就不会被修改的对象。
<br>一个对象技术上不是不可变的，但是在发布后状态就不会变化，这样的对象被称作有效不可变对象。使用有效不可变对象可以简化开发，并且由于减少了同步的使用，提高了程序的性能。
> 任何线程都可以在没有额外同步下安全的使用一个安全发布的有效不可变对象

### 可变对象
如果对象在创建后被修改，那么安全发布仅仅可以保证"发布当时"的状态可见。对于可变状态，同步不仅仅由于对象发布，而且还用于在每次对象访问后，保证后续变化的可见性。为了保证安全的共享可变对象，可变对象必须是被安全发布，同时必须是线程安全的或被锁保护的。
> 发布对象的必要条件依赖于对象的可变性：
> - 不可变对象可以被任意机制发布
> - 有效不可变对象必须安全发布
> - 可变对象必须安全发布，同时必须是线程安全的或者被锁保护的

### 安全的共享对象
在并发程序中，使用和共享对象的一些最有效的策略如下：
- 线程限制：一个线程限制的对象，通过限制在线程中，而被线程独占，且只能被占有他的线程修改。
- 共享只读：一个共享的只读对象，在没有额外同步的情况下，可以被多个线程并发的访问，但是任何线程都不能修改他，共享只读包括可变对象与有效不可变对象
- 共享线程安全：一个线程安全的对象在内部进行同步，所以其他线程无须额外同步，就可以通过公共接口随意的访问他。
- 被守护的：一个被守护的对象只能通过特定的锁来访问。被守护的对象包括那些被线程安全对象封装的对象，和已知被特定锁保护起来的已发布的对象。

